import { supabase } from '../../../lib/supabase';
import { Question, Explanation } from '../types';

/**
 * Interface mapping the exact shape of a Question row in the Supabase 'questions' table.
 */
interface QuestionDBRow {
  /** The UUID generated by the database. */
  id: string;
  /** The business logic ID used in the app (e.g., "BIO1"). */
  v1_id: string;
  /** The subject of the question. */
  subject: string;
  /** The topic within the subject. */
  topic: string;
  /** The sub-topic within the topic. */
  subTopic: string;
  /** The name of the exam the question is from. */
  examName: string;
  /** The year of the exam. */
  examYear: number;
  /** The shift or date of the exam. */
  examDateShift: string;
  /** Difficulty level (Easy/Medium/Hard). */
  difficulty: string;
  /** Type of question (e.g., MCQ). */
  questionType: string;
  /** The question text (English). */
  question: string;
  /** The question text (Hindi). */
  question_hi: string;
  /** Array of option texts (English). */
  options: string[];
  /** Array of option texts (Hindi). */
  options_hi: string[];
  /** The correct answer text. */
  correct: string;
  /** Array of tag strings. */
  tags: string[];
  /** JSONB object containing the explanation. */
  explanation: Explanation;
}

/**
 * Fetches lightweight metadata for all available questions.
 *
 * This function retrieves only the columns necessary for filtering (Subject, Topic, Difficulty, etc.),
 * skipping the heavy text fields (Question, Options, Explanations). This drastically reduces
 * payload size and initial load time, allowing for a responsive configuration UI.
 *
 * It handles pagination automatically to fetch all records.
 *
 * @param {function} [onProgress] - Optional callback to report download progress (fetched vs total).
 * @returns {Promise<Question[]>} A promise resolving to a list of Question objects (with empty content fields).
 */
export const fetchQuestionMetadata = async (
  onProgress?: (fetchedCount: number, totalCount: number) => void
): Promise<Question[]> => {
  let allRows: Partial<QuestionDBRow>[] = [];
  
  // Get Total Count to enable progress tracking
  const { count, error: countError } = await supabase
    .from('questions')
    .select('*', { count: 'exact', head: true });

  if (countError) {
      console.error('Error fetching count:', countError);
  }
  const totalRecords = count || 0;
  
  let from = 0;
  const limit = 1000;
  let hasMore = true;

  // Select ONLY columns needed for filtering logic.
  // Minimizes bandwidth usage.
  const columnsToSelect = 'v1_id, subject, topic, subTopic, examName, examYear, examDateShift, difficulty, questionType, tags';

  try {
    while (hasMore) {
      const { data, error } = await supabase
        .from('questions')
        .select(columnsToSelect)
        .range(from, from + limit - 1);

      if (error) throw error;

      if (data && data.length > 0) {
        allRows = [...allRows, ...data];
        if (onProgress) onProgress(allRows.length, totalRecords);
        
        if (data.length < limit) hasMore = false;
        else from += limit;
      } else {
        hasMore = false;
      }
    }
  } catch (error) {
    console.error("Failed to fetch metadata:", error);
    throw error;
  }

  // Map the raw DB rows to the internal Question model structure.
  // Note: Content fields like 'question' and 'options' are left empty/default.
  return allRows.map((row) => ({
    id: row.v1_id!, 
    sourceInfo: {
      examName: row.examName || '',
      examYear: row.examYear || 0,
      examDateShift: row.examDateShift,
    },
    classification: {
      subject: row.subject || '',
      topic: row.topic || '',
      subTopic: row.subTopic,
    },
    tags: row.tags || [],
    properties: {
      difficulty: row.difficulty || 'Medium',
      questionType: row.questionType || 'MCQ',
    },
    // Placeholder values for non-metadata fields
    question: '',
    options: [],
    correct: '',
    explanation: {},
  }));
};

/**
 * Fetches the full content for a specific list of Question IDs.
 *
 * This is called when the user actually starts a quiz. It retrieves the full text, options,
 * and explanations for the selected subset of questions.
 *
 * @param {string[]} ids - The list of Question IDs (`v1_id`) to fetch.
 * @returns {Promise<Question[]>} A promise resolving to the fully populated Question objects.
 */
export const fetchQuestionsByIds = async (ids: string[]): Promise<Question[]> => {
  if (ids.length === 0) return [];

  // Use the .in() filter to fetch specific records.
  // Note: URL length limits may apply for extremely large sets, but typical quiz sizes are safe.
  const { data, error } = await supabase
    .from('questions')
    .select('*')
    .in('v1_id', ids);

  if (error) {
    console.error("Error fetching full questions:", error);
    throw error;
  }

  // Map the DB rows to the full Question model
  return (data as QuestionDBRow[]).map((row) => ({
    id: row.v1_id, 
    sourceInfo: {
      examName: row.examName,
      examYear: row.examYear,
      examDateShift: row.examDateShift,
    },
    classification: {
      subject: row.subject,
      topic: row.topic,
      subTopic: row.subTopic,
    },
    tags: row.tags || [],
    properties: {
      difficulty: row.difficulty,
      questionType: row.questionType,
    },
    question: row.question,
    question_hi: row.question_hi,
    options: row.options,
    options_hi: row.options_hi,
    correct: row.correct,
    explanation: row.explanation,
  }));
};
